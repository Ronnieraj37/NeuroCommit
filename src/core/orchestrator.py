"""
Main workflow orchestrator for the AI Code Modification Agent.
Coordinates the entire process from request intake to PR creation.
"""
import logging
import os
import tempfile
from pathlib import Path
from typing import Dict, Any, Optional

from src.core.queue import TaskQueue
from src.repo.github_client import GitHubClient
from src.repo.git_operations import GitOperations
from src.ai.claude_client import ClaudeClient
from src.analyzer.project import ProjectAnalyzer
from src.editor.code_editor import CodeEditor
from src.testing.runner import TestRunner

logger = logging.getLogger(__name__)

class Orchestrator:
    def __init__(self, config: Dict[str, Any]):
        """
        Initialize the orchestrator with necessary components.
        
        Args:
            config: Configuration dictionary
        """
        self.config = config
        self.task_queue = TaskQueue()
        self.github_client = GitHubClient(config.get("github_token", ""))
        self.claude_client = ClaudeClient(config.get("claude_api_key", ""))
    
    async def process_request(self, repo_url: str, feature_description: str, target_branch: str = "main") -> str:
        """
        Process a code modification request from start to finish.
        
        Args:
            repo_url: URL of the GitHub repository
            feature_description: Description of the feature to implement
            target_branch: Branch to create PR against
            
        Returns:
            PR URL if successful, error message otherwise
        """
        # Generate a unique task ID
        task_id = self.task_queue.add_task(repo_url, feature_description)
        logger.info(f"Processing request {task_id} for repo {repo_url}")
        
        # Create temporary directory for the repository
        with tempfile.TemporaryDirectory() as temp_dir:
            repo_path = Path(temp_dir) / "repo"
            
            try:
                # 1. Fork and clone repository
                repo_info = await self.github_client.fork_repository(repo_url)
                git_ops = GitOperations(repo_path)
                await git_ops.clone_repository(repo_info["clone_url"])
                
                # 2. Create new branch
                branch_name = f"feature/{task_id}"
                await git_ops.create_branch(branch_name)
                
                # 3. Analyze project structure
                analyzer = ProjectAnalyzer(repo_path)
                project_structure = await analyzer.analyze()
                
                # 4. Get AI to understand the task and generate a plan
                plan = await self.claude_client.generate_plan(
                    feature_description, 
                    project_structure
                )
                
                # 5. Execute the plan (file modifications)
                editor = CodeEditor(repo_path)
                modifications = await self.execute_plan(plan, editor, analyzer)
                
                # 6. Run tests to validate changes
                test_runner = TestRunner(repo_path)
                test_results = await test_runner.run_tests()
                
                if not test_results.success:
                    # 7. If tests fail, ask AI to fix issues
                    fix_plan = await self.claude_client.fix_test_failures(
                        test_results.failures,
                        modifications
                    )
                    await self.execute_plan(fix_plan, editor, analyzer)
                    
                    # Run tests again
                    test_results = await test_runner.run_tests()
                    if not test_results.success:
                        logger.warning(f"Tests still failing after fixes: {test_results.failures}")
                
                # 8. Commit and push changes
                commit_message = f"Add feature: {feature_description}"
                await git_ops.commit_changes(commit_message)
                await git_ops.push_changes(branch_name)
                
                # 9. Create pull request
                # When creating the pull request:
                pr_url = await self.github_client.create_pull_request(
                    repo_info.get("original_owner", repo_info["owner"]),  # Use original owner if available
                    repo_info["name"],
                    branch_name,
                    target_branch,
                    f"Add feature: {feature_description}",
                    f"This PR implements the following feature:\n\n{feature_description}\n\nAutomatically generated by AI Code Agent."
                )
                
                logger.info(f"Successfully created PR: {pr_url}")
                return pr_url
            
            except Exception as e:
                logger.error(f"Error processing request {task_id}: {str(e)}")
                return f"Error: {str(e)}"
        
    async def execute_plan(self, plan: Dict[str, Any], editor: CodeEditor, analyzer: ProjectAnalyzer) -> Dict[str, Any]:
        """
        Execute the modification plan generated by the AI.
        
        Args:
            plan: The modification plan from the AI
            editor: Code editor instance
            analyzer: Project analyzer instance
            
        Returns:
            Details of modifications made
        """
        modifications = {}
        
        for file_change in plan.get("file_changes", []):
            file_path = file_change.get("path")
            change_type = file_change.get("type")
            
            try:
                if change_type == "create":
                    content = file_change.get("content")
                    await editor.create_file(file_path, content)
                    modifications[file_path] = {"type": "create", "content": content}
                    
                elif change_type == "modify":
                    edits = file_change.get("edits", [])
                    for edit in edits:
                        try:
                            if edit.get("type") == "add_method":
                                class_name = edit.get("class_name")
                                method_code = edit.get("method_code")
                                await editor.add_method_to_class(file_path, class_name, method_code)
                            elif edit.get("type") == "replace":
                                pattern = edit.get("pattern")
                                replacement = edit.get("replacement")
                                try:
                                    await editor.replace_code(file_path, pattern, replacement)
                                except ValueError as e:
                                    # If pattern not found, try to append content instead
                                    logger.warning(f"Could not replace code in {file_path}: {str(e)}")
                                    await editor.append_to_file(file_path, replacement)
                            elif edit.get("type") == "insert":
                                location = edit.get("location")
                                code = edit.get("code")
                                try:
                                    await editor.insert_code(file_path, location, code)
                                except ValueError as e:
                                    # If location not found, try to append content instead
                                    logger.warning(f"Could not insert code in {file_path}: {str(e)}")
                                    await editor.append_to_file(file_path, code)
                        except Exception as e:
                            logger.warning(f"Error applying edit to {file_path}: {str(e)}. Continuing with next edit.")
                    
                    modifications[file_path] = {"type": "modify", "edits": edits}
            except Exception as e:
                logger.warning(f"Error processing file {file_path}: {str(e)}. Continuing with next file.")
        
        return modifications